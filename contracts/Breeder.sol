// SPDX-License-Identifier: MIT

pragma solidity >=0.7.0 <0.9.0;

import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol';
import '@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import './Base64.sol';

contract Breeder is ERC721, ERC721URIStorage, Ownable, ReentrancyGuard {
  using Strings for uint256;

  struct TraitStruct {
    string name;
    string description;
    string weapon;
    string image;
    string environment;
    string bgHue;
    string textHue;
    uint256 rarity;
    bool breeded;
    uint256[] parents;
  }

  struct MintStruct {
    uint256 id;
    address owner;
    uint256 mintCost;
    uint256 timestamp;
    TraitStruct traits;
  }

  string[] weapons = ['Stick', 'Knife', 'Blade', 'Club', 'Ax', 'Sword', 'Spear', 'Halberd'];
  string[] environments = [
    'Space',
    'Sky',
    'Deserts',
    'Forests',
    'Grasslands',
    'Mountains',
    'Oceans',
    'Rainforests'
  ];
  uint256[] rarities = new uint256[](5);

  uint256 private totalSupply;
  uint256 private mintCost = 0.002 ether;
  mapping(uint256 => MintStruct) minted;
  mapping(uint256 => bool) tokenIdExist;

  constructor() ERC721('Breeder NFT', 'BFT') {}

  // public
  function mint() public payable nonReentrant {
    require(msg.value >= mintCost, 'Insufficient fund for minting');

    MintStruct memory nft = createNFT(weapons, environments, rarities, false);

    minted[nft.id] = nft;
    tokenIdExist[nft.id] = true;
    totalSupply++;

    _safeMint(msg.sender, nft.id);
  }

  function breedNft(uint256 _fatherTokenId, uint256 _motherTokenId) public payable nonReentrant {
    require(tokenIdExist[_fatherTokenId], 'Father does not exist');
    require(tokenIdExist[_motherTokenId], 'Mother does not exist');
    require(msg.value >= mintCost, 'Insufficient fund for minting');

    // Boast the chances of inheriting parents weapons
    string[] memory familyWeapons = new string[](weapons.length);
    familyWeapons = weapons;

    uint256 weaponToEliminate = randomNum(weapons.length, currentTime(), 0);
    familyWeapons[0] = minted[_fatherTokenId].traits.weapon;

    weaponToEliminate = randomNum(weapons.length, currentTime(), 0);
    familyWeapons[1] = minted[_motherTokenId].traits.weapon;

    // Boast the chances of inheriting parents environment
    string[] memory familyEnvironments = new string[](weapons.length);
    familyEnvironments = environments;

    uint256 envToEliminate = randomNum(environments.length, currentTime(), 0);
    familyEnvironments[envToEliminate] = minted[_fatherTokenId].traits.environment;

    envToEliminate = randomNum(environments.length, currentTime(), 0);
    familyEnvironments[envToEliminate] = minted[_motherTokenId].traits.environment;

    // Create the NFT with the characteristics
    MintStruct memory nft = createNFT(familyWeapons, familyEnvironments, rarities, true);

    minted[nft.id] = nft;
    tokenIdExist[nft.id] = true;
    totalSupply++;

    _safeMint(msg.sender, nft.id);

    // Assign parents to child NFT
    minted[nft.id].traits.parents = [_fatherTokenId, _motherTokenId];
  }

  function createNFT(
    string[] memory _weapons,
    string[] memory _environments,
    uint256[] memory _rarities,
    bool _breed
  ) internal view returns (MintStruct memory nft) {
    require(totalSupply + 1 <= 1000, 'Out of tokens, check back later');

    nft.id = totalSupply + 1;
    nft.owner = msg.sender;
    nft.mintCost = mintCost;
    nft.timestamp = currentTime();

    TraitStruct memory traits;
    traits.name = string(abi.encodePacked(symbol(), ' #', nft.id.toString()));
    traits.description = _breed
      ? 'This NFT inherited its attributes from our randomly generated NFTs.'
      : 'This NFT is randomly generated by our algorithm.';
    traits.weapon = _weapons[randomNum(_weapons.length, currentTime(), 0)];
    traits.environment = _environments[randomNum(_environments.length, currentTime(), 0)];
    traits.rarity = _rarities[randomNum(_rarities.length, currentTime(), 0)];
    traits.bgHue = randomNum(361, currentTime(), nft.id).toString();
    traits.textHue = randomNum(361, block.timestamp, nft.id).toString();
    traits.image = string(
      abi.encodePacked(
        'data:image/svg+xml;base64,',
        buildImage(traits.bgHue, traits.textHue, traits.name)
      )
    );
    traits.breeded = _breed;
    nft.traits = traits;

    return nft;
  }

  function randomNum(uint256 _mod, uint256 _seed, uint256 _salt) public view returns (uint256) {
    uint256 num = uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender, _seed, _salt))) %
      _mod;
    return num;
  }

  function buildImage(
    string memory bgHue,
    string memory textHue,
    string memory name
  ) public pure returns (string memory) {
    return
      Base64.encode(
        bytes(
          abi.encodePacked(
            '<svg width="500" height="500" xmlns="http://www.w3.org/2000/svg">',
            '<rect height="500" width="500" fill="hsl(',
            bgHue,
            ', 50%, 25%)"/>',
            '<text x="50%" y="50%" dominant-baseline="middle" fill="hsl(',
            textHue,
            ', 100%, 80%)" text-anchor="middle" font-size="41">',
            name,
            '</text>',
            '</svg>'
          )
        )
      );
  }

  function buildMetadata(uint256 _tokenId) internal view returns (string memory) {
    MintStruct memory nft = minted[_tokenId];
    uint256 timestamp = currentTime();

    bytes memory attributesJson = buildAttributesJson(
      nft.traits.environment,
      nft.traits.weapon,
      nft.traits.rarity,
      timestamp
    );

    return
      string(
        abi.encodePacked(
          'data:application/json;base64,',
          Base64.encode(
            bytes(
              abi.encodePacked(
                '{"id":"',
                nft.id.toString(),
                '","name":"',
                nft.traits.name,
                '","description":"',
                nft.traits.description,
                '","price":"',
                nft.mintCost.toString(),
                '","image":"',
                nft.traits.image,
                '","attributes":',
                attributesJson,
                '}'
              )
            )
          )
        )
      );
  }

  function buildAttributesJson(
    string memory _environment,
    string memory _weapon,
    uint256 _rarity,
    uint256 _timestamp
  ) internal pure returns (bytes memory) {
    return
      abi.encodePacked(
        '[{"trait_type":"Environment","value":"',
        _environment,
        '"},',
        '{"trait_type":"Weapon","value":"',
        _weapon,
        '"},',
        '{"trait_type":"Rarity","value":"',
        _rarity.toString(),
        '"},',
        '{"display_type":"date","trait_type":"Created","value":"',
        _timestamp.toString(),
        '"}]'
      );
  }

  function tokenURI(
    uint256 _tokenId
  ) public view override(ERC721, ERC721URIStorage) returns (string memory) {
    require(_exists(_tokenId), 'ERC721Metadata: URI query for nonexistent token');

    return buildMetadata(_tokenId);
  }

  function currentTime() internal view returns (uint256) {
    uint256 newNum = (block.timestamp * 1000) + 1000;
    return newNum;
  }

  function _burn(uint256 _tokenId) internal override(ERC721, ERC721URIStorage) {
    super._burn(_tokenId);
  }

  function supportsInterface(
    bytes4 interfaceId
  ) public view virtual override(ERC721, ERC721URIStorage) returns (bool) {
    return super.supportsInterface(interfaceId);
  }

  function getAllNfts() public view returns (MintStruct[] memory Minted) {
    Minted = new MintStruct[](totalSupply);
    for (uint256 i = 0; i < totalSupply; i++) {
      Minted[i] = minted[i + 1];
    }
  }

  function getMintedNfts() public view returns (MintStruct[] memory Minted) {
    uint256 available;
    for (uint256 i = 0; i < totalSupply; i++) {
      if (!minted[i + 1].traits.breeded) available++;
    }

    Minted = new MintStruct[](available);

    uint256 index;
    for (uint256 i = 0; i < totalSupply; i++) {
      if (!minted[i + 1].traits.breeded) Minted[index++] = minted[i + 1];
    }
  }

  function getBreededNfts() public view returns (MintStruct[] memory Minted) {
    uint256 available;
    for (uint256 i = 0; i < totalSupply; i++) {
      if (minted[i + 1].traits.breeded) available++;
    }

    Minted = new MintStruct[](available);

    uint256 index;
    for (uint256 i = 0; i < totalSupply; i++) {
      if (minted[i + 1].traits.breeded) Minted[index++] = minted[i + 1];
    }
  }

  function getMyNfts() public view returns (MintStruct[] memory Minted) {
    uint256 available;
    for (uint256 i = 0; i < totalSupply; i++) {
      if (minted[i + 1].owner == msg.sender) available++;
    }

    Minted = new MintStruct[](available);

    uint256 index;
    for (uint256 i = 0; i < totalSupply; i++) {
      if (minted[i + 1].owner == msg.sender) Minted[index++] = minted[i + 1];
    }
  }

  function getParentsOf(uint256 _tokenId) public view returns (MintStruct[] memory Minted) {
    if (!minted[_tokenId].traits.breeded) {
      Minted = new MintStruct[](0);
      return Minted;
    }

    Minted = new MintStruct[](minted[_tokenId].traits.parents.length);
    uint256 index;
    for (uint256 i = 0; i < totalSupply; i++) {
      if (
        minted[i + 1].id == minted[_tokenId].traits.parents[0] ||
        minted[i + 1].id == minted[_tokenId].traits.parents[1]
      ) {
        Minted[index++] = minted[i + 1];
      }
    }
  }

  function getNft(uint256 _tokenId) public view returns (MintStruct memory) {
    return minted[_tokenId];
  }
}
